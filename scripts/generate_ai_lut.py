#!/usr/bin/env python3
"""
Generate AI Lookup Table for Genesis Pong
Precomputes neural network decisions for all quantized input combinations
"""

import numpy as np
import sys
import os

# Add scripts directory to path to import existing model
sys.path.append('../scripts')

# Try to load the trained model if available
try:
    import tensorflow as tf
    model = tf.keras.models.load_model('../models/pong_ai_model.h5', compile=False)
    print("âœ“ Loaded trained neural network model")
    use_neural_network = True
except:
    print("âš  No trained model found, using simple predictive AI for lookup table")
    use_neural_network = False

# Lookup table dimensions (matching ai_lut.c)
LUT_BALL_X_STEPS = 20    # 320/16 = 20 steps
LUT_BALL_Y_STEPS = 14    # 224/16 = 14 steps  
LUT_VEL_STEPS = 5        # -2, -1, 0, 1, 2
LUT_AI_Y_STEPS = 14      # 224/16 = 14 steps

def simple_predictive_ai(ball_x, ball_y, ball_vx, ball_vy, ai_y):
    """Simple predictive AI (fallback if no neural network)"""
    # Predict where ball will be when it reaches paddle
    ball_future_y = ball_y
    if ball_vx > 0:  # Ball moving toward AI
        if ball_vx != 0:
            time_to_paddle = (290 - ball_x) / ball_vx
            ball_future_y = ball_y + (ball_vy * time_to_paddle)
            
            # Handle wall bounces
            while ball_future_y < 0 or ball_future_y > 224:
                if ball_future_y < 0: 
                    ball_future_y = -ball_future_y
                if ball_future_y > 224: 
                    ball_future_y = 224 - (ball_future_y - 224)
    
    paddle_center = ai_y + 24  # Paddle is 48 pixels tall
    diff = ball_future_y - paddle_center
    
    # Dead zone to avoid jittery movement
    if diff < -8: 
        return 0  # Move up
    elif diff > 8: 
        return 2  # Move down
    else:
        return 1  # Stay

def neural_network_ai(ball_x, ball_y, ball_vx, ball_vy, ai_y):
    """Use the trained neural network"""
    # Normalize inputs to match training (from pong_ai_train.py)
    state = np.array([
        (ball_x - 160) / 160.0,      # Ball X position normalized around center
        (ball_y - 112) / 112.0,      # Ball Y position normalized around center
        ball_vx / 5.0,               # Ball X velocity normalized  
        ball_vy / 5.0,               # Ball Y velocity normalized
        (ai_y - 88) / 88.0           # AI paddle Y position normalized
    ])
    
    # Get prediction from neural network
    q_values = model.predict(state.reshape(1, -1), verbose=0)
    return np.argmax(q_values[0])

def generate_lookup_table():
    """Generate the complete lookup table"""
    print(f"Generating {LUT_BALL_X_STEPS}Ã—{LUT_BALL_Y_STEPS}Ã—{LUT_VEL_STEPS}Ã—{LUT_VEL_STEPS}Ã—{LUT_AI_Y_STEPS} lookup table...")
    
    total_entries = LUT_BALL_X_STEPS * LUT_BALL_Y_STEPS * LUT_VEL_STEPS * LUT_VEL_STEPS * LUT_AI_Y_STEPS
    print(f"Total entries: {total_entries}")
    print(f"Memory usage: {total_entries} bytes = {total_entries/1024:.1f} KB")
    
    lookup_table = []
    entry_count = 0
    
    for bx in range(LUT_BALL_X_STEPS):
        for by in range(LUT_BALL_Y_STEPS):
            for vx in range(LUT_VEL_STEPS):
                for vy in range(LUT_VEL_STEPS):
                    for ay in range(LUT_AI_Y_STEPS):
                        # Convert indices back to actual game values
                        ball_x = bx * 16  # 0, 16, 32, ..., 304
                        ball_y = by * 16  # 0, 16, 32, ..., 208
                        ball_vx = vx - 2  # -2, -1, 0, 1, 2
                        ball_vy = vy - 2  # -2, -1, 0, 1, 2
                        ai_y = ay * 16    # 0, 16, 32, ..., 208
                        
                        # Get AI decision
                        if use_neural_network:
                            action = neural_network_ai(ball_x, ball_y, ball_vx, ball_vy, ai_y)
                        else:
                            action = simple_predictive_ai(ball_x, ball_y, ball_vx, ball_vy, ai_y)
                        
                        lookup_table.append(action)
                        entry_count += 1
                        
                        # Progress indicator
                        if entry_count % 1000 == 0:
                            progress = (entry_count / total_entries) * 100
                            print(f"Progress: {progress:.1f}% ({entry_count}/{total_entries})")
    
    return lookup_table

def write_c_array(lookup_table, output_file):
    """Write the lookup table as a C array"""
    print(f"Writing C array to {output_file}...")
    
    with open(output_file, 'w') as f:
        f.write("// Auto-generated AI lookup table for Genesis Pong\n")
        f.write("// Generated by generate_ai_lut.py\n\n")
        f.write("#include \"ai.h\"\n\n")
        f.write("// Precomputed AI decisions for quantized input space\n")
        f.write("// Each entry is an action: 0=up, 1=stay, 2=down\n")
        f.write(f"const u8 ai_lookup_table[{len(lookup_table)}] = {{\n")
        
        # Write data in rows of 20 for readability
        for i in range(0, len(lookup_table), 20):
            row = lookup_table[i:i+20]
            f.write("    " + ", ".join(map(str, row)))
            if i + 20 < len(lookup_table):
                f.write(",")
            f.write("\n")
        
        f.write("};\n")

def main():
    print("ðŸ§  AI Lookup Table Generator for Sega Genesis")
    print("=" * 50)
    
    # Generate the lookup table
    lookup_table = generate_lookup_table()
    
    # Write to C file
    output_file = "../pong/src/ai_lut_generated.c"
    write_c_array(lookup_table, output_file)
    
    # Statistics
    actions = np.array(lookup_table)
    print("\nðŸ“Š Statistics:")
    print(f"Total entries: {len(lookup_table)}")
    print(f"Memory usage: {len(lookup_table)} bytes ({len(lookup_table)/1024:.1f} KB)")
    print(f"Actions - Up: {np.sum(actions == 0)} ({np.mean(actions == 0)*100:.1f}%)")
    print(f"Actions - Stay: {np.sum(actions == 1)} ({np.mean(actions == 1)*100:.1f}%)")
    print(f"Actions - Down: {np.sum(actions == 2)} ({np.mean(actions == 2)*100:.1f}%)")
    
    print(f"\nâœ… Lookup table generated successfully!")
    print(f"Next steps:")
    print(f"1. Replace the placeholder array in ai_lut.c with the generated one")
    print(f"2. Update main.c to use pong_ai_lookup() instead of pong_ai_NN()")
    print(f"3. Enjoy O(1) AI decisions on your Genesis! ðŸŽ®")

if __name__ == "__main__":
    main()
